(ns exs.clj
  (:require
   [clojure.test :refer :all]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test all solutions (...ones with 'with-test')
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(run-tests 'exs.clj)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(is (= true true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(is (= (- 10 (* 2 3)) 4))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(is (= "HELLO WORLD" (.toUpperCase "hello world")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(is (= (list :a :b :c)'(:a :b :c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(is (= '(1 2 3 4) (conj '(2 3 4) 1)))
(is (= '(1 2 3 4) (conj '(3 4) 2 1)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 7
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc7 [1 2 3 4])

  (is (= fc7 (conj [1 2 3] 4)))
  (is (= fc7 (conj [1 2] 3 4))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc8 #{:a :b :c :d})

(is (= fc8 (set '(:a :a :b :c :c :c :c :d :d))))
(is (= fc8 (clojure.set/union #{:a :b :c} #{:b :c :d}))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 9
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= #{1 2 3 4} (conj #{1 4 3} 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 10
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc10 20)

  (is (= fc10 ((hash-map :a 10, :b 20, :c 30) :b)))
  (is (= fc10 (:b {:a 10, :b 20, :c 30}))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 11
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= {:a 1, :b 2, :c 3} (conj {:a 1} {:b 2} [:c 3]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 12
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc12 3)

  (is (= fc12 (first '(3 2 1))))
  (is (= fc12 (second [2 3 4])))
  (is (= fc12 (last (list 1 2 3)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 13
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= [20 30 40] (rest [10 20 30 40]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 14
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc14 8)

  (is (= fc14 ((fn add-five [x] (+ x 5)) 3)))
  (is (= fc14 ((fn [x] (+ x 5)) 3)))
  (is (= fc14 (#(+ % 5) 3)))
  (is (= fc14 ((partial + 5) 3))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 15
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc15 #(* 2 %))

  (is (= (fc15 2) 4))
  (is (= (fc15 3) 6))
  (is (= (fc15 11) 22))
  (is (= (fc15 7) 14)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc16 #(str "Hello, " % "!"))

  (is (= (fc16  "Dave") "Hello, Dave!"))
  (is (= (fc16  "Jenn") "Hello, Jenn!"))
  (is (= (fc16  "Rhea") "Hello, Rhea!")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 17
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

'(6 7 8)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 18
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

'(6 7)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 19
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc19 #(first (reverse %)))

  (is (= (fc19 [1 2 3 4 5]) 5))
  (is (= (fc19 '(5 4 3)) 3))
  (is (= (fc19 ["b" "c" "d"]) "d")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 20
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc20 #(-> % butlast reverse first))

  (is (= (fc20 (list 1 2 3 4 5)) 4))
  (is (= (fc20 ["a" "b" "c"]) "b"))
  (is (= (fc20 [[1 2] [3 4]]) [1 2])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 21
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc21 [s n]
    (last (take (inc n) s)))

  (is (= (fc21 '(4 5 6 7) 2) 6))
  (is (= (fc21 [:a :b :c] 0) :a))
  (is (= (fc21 [1 2 3 4] 1) 2))
  (is (= (fc21 '([1 2] [3 4] [5 6]) 2) [5 6])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 22
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc22 [s]
    (.length (vec s)))

  (is (= (fc22 '(1 2 3 3 1)) 5))
  (is (= (fc22 "Hello World") 11))
  (is (= (fc22 [[1 2] [3 4] [5 6]]) 3))
  (is (= (fc22 '(13)) 1))
  (is (= (fc22 '(:a :b :c)) 3)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 23
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc23 [s]
    (into '() s))

  (is (= (fc23 [1 2 3 4 5]) [5 4 3 2 1]))
  (is (= (fc23 (sorted-set 5 7 2 7)) '(7 5 2)))
  (is (= (fc23 [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 24
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc24 [a]
    (reduce + a))

  (is (= (fc24 [1 2 3]) 6))
  (is (= (fc24 (list 0 -2 5 5)) 8))
  (is (= (fc24 #{4 2 1}) 7))
  (is (= (fc24 '(0 0 -1)) -1))
  (is (= (fc24 '(1 10 3)) 14)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 25
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc25 [coll]
    (filter odd? coll))

  (is (= (fc25 #{1 2 3 4 5}) '(1 3 5)))
  (is (= (fc25 [4 2 1 6]) '(1)))
  (is (= (fc25 [2 2 4 6]) '()))
  (is (= (fc25 [1 1 1 3]) '(1 1 1 3))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 26
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def fib
  (lazy-cat
   [1 1]
   (map + fib (rest fib))))

(with-test
  (defn fc26 [n]
    (take n fib))

  (is (= (fc26 3) '(1 1 2)))
  (is (= (fc26 6) '(1 1 2 3 5 8)))
  (is (= (fc26 8) '(1 1 2 3 5 8 13 21))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 27
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc27 [s]
    (let [cnt   (count s)
          split (if (odd? cnt) (/ (dec cnt) 2) (/ cnt 2))]
      (= (take split s) (take split (reverse s)))))

  (is (false? (fc27 '(1 2 3 4 5))))
  (is (true?  (fc27 "racecar")))
  (is (true?  (fc27 [:foo :bar :foo])))
  (is (true?  (fc27 '(1 1 3 3 1 1))))
  (is (false? (fc27 '(:a :b :c)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 28
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc28 [s]
    (filter (complement sequential?)
          (rest (tree-seq sequential? seq s))))

  (is (= (fc28 '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6)))
  (is (= (fc28 ["a" ["b"] "c"]) '("a" "b" "c")))
  (is (= (fc28 '((((:a))))) '(:a))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 29
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc29 [s]
    (->> s
         (filterv #(re-matches #"[A-Z]" (str %)))
         clojure.string/join))

  (is (= (fc29 "HeLlO, WoRlD!") "HLOWRD"))
  (is (empty? (fc29 "nothing")))
  (is (= (fc29 "$#A(*&987Zf") "AZ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 30
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(fn deduper [acc s]
  (let [xs   (first s)
        ss   (last acc)
        ys   (rest s)
        dup? (= xs ss)]
    (if (empty? ys)
      (reverse (into '() (if-not dup? (conj acc xs) acc)))
      (deduper (if-not dup? (conj acc xs) acc) ys))))

(with-test
  (defn fc30 [s]
    (deduper [] s))

  (is (= (apply str (fc30 "Leeeeeerrroyyy")) "Leroy"))
  (is (= (fc30 [1 1 2 3 3 2 2 3]) '(1 2 3 2 3)))
  (is (= (fc30 [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 31
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc31 [s]
    (partition-by identity s))

  (is (= (fc31 [1 1 2 1 1 1 3 3]) '((1 1) (2) (1 1 1) (3 3))))
  (is (= (fc31 [:a :a :b :b :c]) '((:a :a) (:b :b) (:c))))
  (is (= (fc31 [[1 2] [1 2] [3 4]]) '(([1 2] [1 2]) ([3 4])))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc32 [s]
    (mapcat (fn [i] [i i]) s))

  (is (= (fc32 [1 2 3]) '(1 1 2 2 3 3)))
  (is (= (fc32 [:a :a :b :b]) '(:a :a :a :a :b :b :b :b)))
  (is (= (fc32 [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4])))
  (is (= (fc32 [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 33
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Write a function which replicates each element of a sequence a variable number of times.
;; (= (__ [1 2 3] 2) '(1 1 2 2 3 3))
;; (= (__ [:a :b] 4) '(:a :a :a :a :b :b :b :b))
;; (= (__ [4 5 6] 1) '(4 5 6))
;; (= (__ [[1 2] [3 4]] 2) '([1 2] [1 2] [3 4] [3 4]))
;; (= (__ [44 33] 2) [44 44 33 33])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 34
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Write a function which creates a list of all integers in a given range.
;; (= (__ 1 4) '(1 2 3))
;; (= (__ -2 2) '(-2 -1 0 1))
;; (= (__ 5 8) '(5 6 7))
;; Special Restrictions
;; range

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 35
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Clojure lets you give local names to values using the special let-form. (= __ (let [x 5] (+ 2 x)))
;; (= __ (let [x 3, y 10] (- y x)))
;; (= __ (let [x 21] (let [y 3] (/ x y))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 36
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Can you bind x, y, and z so that these are all true?
;; (= 10 (let __ (+ x y)))
;; (= 4 (let __ (+ y z)))
;; (= 1 (let __ z))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 37
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Regex patterns are supported with a special reader macro.
;; (= __ (apply str (re-seq #"[A-Z]+" "bA1B3Ce ")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 38
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Write a function which takes a variable number of parameters and returns the maximum value.
;; (= (__ 1 8 3 4) 8)
;; (= (__ 30 20) 30)
;; (= (__ 45 67 11) 67)
;; Special Restrictions
;; max
;; max-key


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 39
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Write a function which takes two sequences and returns the first item from each, then the second item from each, then the third, etc.

;; (= (__ [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))
;; (= (__ [1 2] [3 4 5 6]) '(1 3 2 4))
;; (= (__ [1 2 3 4] [5]) [1 5])
;; (= (__ [30 20] [25 15]) [30 25 20 15])
;; Special Restrictions
;; interleave


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 40
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Write a function which separates the items of a sequence by an arbitrary value.
;; (= (__ 0 [1 2 3]) [1 0 2 0 3])
;; (= (apply str (__ ", " ["one" "two" "three"])) "one, two, three")
;; (= (__ :z [:a :b :c :d]) [:a :z :b :z :c :z :d])
;; Special Restrictions
;; interpose

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 41
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 42
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 43
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 44
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 45
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 46
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 47
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 48
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc48 6)

  (is (= fc48 (some #{2 7 6} [5 6 7 8])))
  (is (= fc48 (some #(when (even? %) %) [5 6 7 8]))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 58
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc58 [& fns]
    (fn [& args]
    (first
     (reduce (fn [res f]
               (list (apply f res)))
             args
             (reverse fns)))))

  (is (= [3 2 1] ((fc58 rest reverse) [1 2 3 4])))
  (is (= 5       ((fc58 (partial + 3) second) [1 2 3 4])))
  (is (= true    ((fc58 zero? #(mod % 8) +) 3 5 7 9)))
  (is (= "HELLO" ((fc58 #(.toUpperCase %) #(apply str %) take) 5 "hello world"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 66
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc66 [a b]
    (if (zero? b)
      a
      (recur b (mod a b))))

  (is (= (fc66 2 4) 2))
  (is (= (fc66 10 5) 5))
  (is (= (fc66 5 7) 1))
  (is (= (fc66 1023 858) 33)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 97
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn pascals-triangle [acc max]
  (let [row #(conj (into [1] (map (fn [c] (reduce + c)) (partition 2 1 %))) 1)]
    (if (= (count acc) max)
      acc
      (recur (conj acc (row (last acc))) max))))

(with-test
  (defn fc97 [n]
    (last (pascals-triangle [[1]] n)))

  (is (= (fc97 1) [1]))
  (is (= (map fc97 (range 1 6)))
      [[1]
       [1 1]
       [1 2 1]
       [1 3 3 1]
       [1 4 6 4 1]])
  (is (= (fc97 11)
         [1 10 45 120 210 252 210 120 45 10 1])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 115
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (def fc115
    (fn [n]
      (if (zero? n)
        true
        (let [num (str n)
              cnt (count num)
              div (if (odd? cnt)
                    (dec (/ cnt 2))
                    (/ cnt 2))
              a   (reduce + (map #(Integer/parseInt (str %)) (take div num)))
              b   (reduce + (map #(Integer/parseInt (str %)) (take div (reverse num))))]
          (= a b)))))

  (is (= true  (fc115 11)))
  (is (= true  (fc115 121)))
  (is (= false (fc115 123)))
  (is (= true  (fc115 0)))
  (is (= false (fc115 88099)))
  (is (= true  (fc115 89098)))
  (is (= true  (fc115 89089)))
  (is (= (take 20 (filter fc115 (range)))
         [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 146
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-test
  (defn fc146 [m]
    (into {}
          (apply concat
                 (for [[k v] m]
                   (map #(vector [k (first %)] (second %)) v)))))

  (is (= (fc146 '{a {p 1, q 2}
                  b {m 3, n 4}})
         '{[a p] 1, [a q] 2
           [b m] 3, [b n] 4}))
  (is (= (fc146 '{[1] {a b c d}
                  [2] {q r s t u v w x}})
         '{[[1] a] b, [[1] c] d,
           [[2] q] r, [[2] s] t,
           [[2] u] v, [[2] w] x}))
  (is (= (fc146 '{m {1 [a b c] 3 nil}})
         '{[m 1] [a b c], [m 3] nil})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
